---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(LexOPS)
```

# LexOPS

<!-- badges: start -->
`r usethis::use_lifecycle_badge("maturing")`
`r usethis::use_badge(sprintf("Version: %s", packageVersion("LexOPS")), "", sprintf("https://img.shields.io/badge/version-%s-blue.svg", packageVersion("LexOPS")))`
[![Lifecycle: maturing](https://img.shields.io/badge/lifecycle-maturing-blue.svg)](https://www.tidyverse.org/lifecycle/#maturing)
[![Version: 0.0.0.9001](https://img.shields.io/badge/version-0.0.0.9001-blue.svg)]()
<!-- badges: end -->

LexOPS is an R package for generating word stimuli, for use in Psychology experiments. It can generate stimuli for a factorial design specified by the user, controlling for selected lexical variables. The package has an inbuilt database of features for English words (`LexOPS::lexops`), but the user can also use their own list of features, for English words and/or for words in other languages.

## Installation

LexOPS can be installed as an R package with:

```{r, eval=FALSE}
if (!require("devtools")) install.packages("devtools")
devtools::install_github("JackEdTaylor/LexOPS")
```

## Shiny App

The package features an interactive shiny app, with several useful features for visualising variables' distributions and relationships while generating stimuli. The LexOPS shiny app is available online at [https://jackt.shinyapps.io/lexops/](https://jackt.shinyapps.io/lexops/), but it is usually faster and more relilable to run it locally, with:

```{r, eval=FALSE}
LexOPS::run_shiny()
```

## Generating Stimuli

In addition to the shiny app, LexOPS' functions allow you to easily generate stimuli in a reproducible way.

### The "Generate Pipeline"

The following example pipeline generates 50 words (all nouns) per condition (200 words in total), for a study with a 2 x 2, concreteness (low, high) by bigram probability (low, high) experimental design. Words are controlled for by length exactly, and by word frequency within a tolerance of Â±0.2 Zipf. Matches are generated relative to each condition an equal number of times (`match_null="balanced"`).

```{r, include=FALSE}
set.seed(999)
```

```{r, warning = FALSE}
library(LexOPS)

# generate stimuli
stim <- lexops %>%
  subset(PoS.SUBTLEX_UK == "noun") %>%
  split_by(BG.SUBTLEX_UK, 0.001:0.004 ~ 0.008:0.011) %>%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) %>%
  control_for(Zipf.SUBTLEX_UK, -0.2:0.2) %>%
  control_for(Length) %>%
  generate(n = 50, match_null = "balanced")
```

Let's have a quick preview of what we generated!

```{r}
# create a table of the first 20 words (4 per row) as an example
stim %>%
  head(5) %>%
  knitr::kable()
```

### Review Generated Stimuli

Now we've generated our stimuli, we'll want to check our pipeline has done what we expected. The `plot_design()` function is a handy way to do this. This function plots how distributions of variables that were split by or controlled for differ between conditions. Variables used as splits (i.e. independent variables) should differ between conditions, while variables used as controls should show similar distributions. Words from the same `item_nr` row (see previous table) are joined by lines, and presented in matching colours.

```{r fig1, dpi=400}
plot_design(stim)
```

### Convert to Long Format

The `long_format()` function is a handy way to convert the generated stimuli to long format, which is useful for wrangling the data further. By default, this function returns the generated stimuli in long format, including all the variables specified in the Generate Pipeline (though the `include` argument also allows you to request all variables from the original dataframe).

```{r}
# present the same 20 words as in the last table
long_format(stim) %>%
  head(20) %>%
  knitr::kable()
```
