% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parsers.R
\name{parse_levels}
\alias{parse_levels}
\title{A non-standard evaluation parser}
\usage{
parse_levels(var, levels = NA)
}
\arguments{
\item{var}{A column name (non-standard evaluation).}

\item{levels}{Levels in the form of tilde-separated vectors (e.g. \code{c("noun", "name") ~ c("verb", "adjective")}) or character vectors (e.g. \code{"noun" ~ "verb"}). Numeric levels can be in the form \code{1.5:2.75 ~ 3.5:4.75}.}
}
\value{
Returns a list object in the form \code{list("column_name", c(1, 2), c(3, 4), c(5, 6))}.
}
\description{
This is just a handy function I use for parsing two non-standard variables, a column name and associated tolerances/levels, into a single list object.
}
\examples{

# Numeric sections of a distribution can be specified as lower:upper bound...

parse_levels(substitute(Zipf.SUBTLEX_UK), substitute(1:2 ~ 3:4 ~ 5:6))

# ...or c(lower, upper)

parse_levels(substitute(Zipf.SUBTLEX_UK), substitute(c(1, 2) ~ c(3, 4) ~ c(5, 6)))

# Can give any level as just `NULL` or `NA` to store the level as `NA`
# (e.g. for `split_by_map()` function in future)

parse_levels(substitute(example_variable), substitute(NULL ~ 1.2:4 ~ 5.2:6))
parse_levels(substitute(example_variable), substitute(NA ~ 1.2:4 ~ 5.2:6))

# Non-numeric categories can be specified like so

parse_levels(substitute(PoS.SUBTLEX_UK), substitute("noun" ~ "verb"))

parse_levels(substitute(PoS.SUBTLEX_UK), substitute(c("noun", "name") ~ c("adjective", "verb")))

# Can give no value for `levels` (i.e. `levels` is `NA`),
# e.g. when matching exactly, or categorically

parse_levels(substitute(PoS.SUBTLEX_UK))

# Can give vector of variables in non-standard eval

parse_levels(substitute(c(Zipf.SUBTLEX_UK, Length)), substitute(0:2.5))
parse_levels(substitute(c(Zipf.SUBTLEX_UK, Length)))

}
