% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/control_for_euc.R
\name{control_for_euc}
\alias{control_for_euc}
\title{Control for Euclidean distance in several numeric variables}
\usage{
control_for_euc(
  df,
  vars,
  tol,
  name = NA,
  scale = TRUE,
  center = TRUE,
  weights = NA,
  euc_df = NA,
  cond_col = NA,
  standard_eval = FALSE
)
}
\arguments{
\item{df}{A data frame that is the result from \code{\link{split_by}}.}

\item{vars}{The columns from which to calculate Euclidean distance.}

\item{tol}{The desired control tolerance, in Euclidean distance (will be interpreted as scaled Euclidean distance if \code{scaled == TRUE}).}

\item{name}{What the output column should be named. If \code{NA} (default), will automatically assign as \code{sprintf("control_fun_\%i", nr)}, where \code{nr} is the number of the control function.}

\item{scale, center}{How should variables be scaled and/or centred \emph{before} calculating Euclidean distance? For options, see the \code{scale} and \code{center} arguments of \code{\link[base]{scale}}. Default for both is \code{TRUE}. Scaling can be useful when variables are in differently scaled.}

\item{weights}{An (optional) list of weights, in the same order as \code{vars}. After any scaling is applied, the values will be multiplied by these weights. Default is \code{NA}, meaning no weights are applied.}

\item{euc_df}{The dataframe to calculate the Euclidean distance from. By default, the function will use \code{df}. Giving a different dataframe to \code{euc_df} can be useful in some cases, such as when \code{df} has been filtered for generating stimuli, but you want to calculate Euclidean Distance from a full distribution.}

\item{cond_col}{Prefix with which the columns detailing the splits were labelled by \code{\link{split_by}}. This is rarely needed (default = NA), as by default the function gets this information from \code{df}'s attributes.}

\item{standard_eval}{Logical; bypasses non-standard evaluation, and allows more standard R objects in \code{vars} and \code{tol}. If \code{TRUE}, \code{vars} should be a character vector referring to columns in \code{df} (e.g. \code{c("Zipf.SUBTLEX_UK", "Length")}), and \code{tol} should be a vector of length 2, specifying the tolerance (e.g. \code{c(0, 0.5)}). Default = \code{FALSE}.}
}
\value{
Returns \code{df}, with details on the variables to be controlled for added to the attributes. Run the \code{\link{generate}} function to then generate the actual stimuli.
}
\description{
This function is a wrapper for \code{\link{control_for_map}} that allows you to easily control for Euclidean distance.
}
\examples{

stim <- lexops \%>\%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) \%>\%
  control_for_euc(c(Zipf.BNC.Written, Length), 0:0.005) \%>\%
  generate(10)

# bypass non-standard evaluation
stim <- lexops \%>\%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) \%>\%
  control_for_euc(c("Zipf.BNC.Written", "Length"), c(0, 0.005), standard_eval = TRUE) \%>\%
  generate(10)

# generate stimuli from a filtered dataframe, but calculate
# Euclidean distance from an (original) unfiltered dataframe
library(dplyr)
stim <- lexops \%>\%
  filter(
    Zipf.SUBTLEX_UK <= 5,
    between(Length, 3, 12),
    PK.Brysbaert >= 0.9
  ) \%>\%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) \%>\%
  control_for_euc(
    c(Zipf.SUBTLEX_UK, Length),
    0:0.005,
    name = "Euclidean Distance",
    euc_df = lexops
  ) \%>\%
  generate(10)

}
